---
title: "Computer lab 2 block 2"
author: "Maximilian Pfundstein (maxpf364)"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  html_document:
    df_print: paged
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '3'
bibliography: sources.bib
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = FALSE, cache = TRUE)
library(readxl)
library(ggplot2)
library(knitr)
library(mgcv)
library(pamr)
library(kernlab)
library(glmnet)
set.seed(1234567890)

```

# 1) Using GAM and GLM to examine the mortality rates

The Excel document `influenza.xlsx` contains weekly data on the mortality and the number of laboratory-confirmed cases of influenza in Sweden. In addition, there is information about population-weighted temperature anomalies (temperature deficits).

```{r, echo=FALSE}

################################################################################
# 1) Using GAM and GLM to examine the mortality rates
################################################################################

set.seed(12345)
influanza = read_excel("./influenza.xlsx")
#creditscoring$good_bad = as.factor(creditscoring$good_bad)
kable(head(influanza), caption = "influenza.xlsx")

```

## 1.1)

**Task:** Use time series plots to visually inspect how the mortality and influenza number vary with time (use Time as X axis). By using this plot, comment how the amounts of influenza cases are related to mortality rates.

**Answer:** One plot for mortality and one for influenza. To better compare those two and show, if they are related or not, there is a third plot showing them in one plot.

```{r, echo=FALSE}

################################################################################
# 1.1) 
################################################################################

ggplot(influanza) +
  geom_line(aes(x = influanza$Time, y = influanza$Mortality,
                colour = "Mortality Time Series")) +
  labs(title = "Mortality", y = "Mortality",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("blue"))


ggplot(influanza) +
  geom_line(aes(x = influanza$Time, y = influanza$Influenza,
                colour = "Influenza Time Series")) +
  labs(title = "Influenza", y = "Influenza",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("orange"))

ggplot(influanza) +
  geom_line(aes(x = influanza$Time, y = influanza$Mortality,
                colour = "Mortality Time Series")) +
  geom_line(aes(x = influanza$Time, y = influanza$Influenza,
                colour = "Influenza Time Series")) +
  labs(title = "Superimposed Time Series", y = "Values",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("red", "brown"))
```

If both plots are superimposed we can observe that it seems like that mortality in influenced by influenza.

## 1.2)

**Task:** Use gam() function from mgcv package to fit a GAM model in which Mortality is normally distributed and modelled as a linear function of Year and spline function of Week, and make sure that the model parameters are selected by the generalized cross-validation. Report the underlying probabilistic model.

```{r, echo = FALSE}

################################################################################
# 1.2) 
################################################################################

# - Mortality is normally distributed and modelled as...
# - ...a linear function of Year...
# - ...and spline function of Week
# Don't forget to select the model bei generalized cross-validation

gam_model = gam(formula = Mortality ~ Year + s(Week), family = gaussian(),
                data = influanza, method="GCV.Cp") 

print(gam_model)

```

The probabilistic model looks as follows: 

$$ Model = \mathcal{N}(\beta_{year} * X_{Year} +S_{week} * X_{week} + \alpha,  \sigma^2) $$

## 1.3)

**Task:** Plot predicted and observed mortality against time for the fitted model and comment on the quality of the fit. Investigate the output of the GAM model and report which terms appear to be significant in the model. Is there a trend in mortality change from one year to another? Plot the spline component and interpret the plot.

```{r, echo = FALSE}

################################################################################
# 1.3) 
################################################################################

summary(gam_model)
plot(gam_model)

time = influanza$Time
observed = influanza$Mortality
predicted = gam_model$fitted.values

mortality_values = data.frame(time, observed, predicted)

ggplot(mortality_values) +
  geom_line(aes(x = time, y = observed,
                colour = "Observed Mortality")) +
  geom_line(aes(x = time, y = predicted,
                colour = "Predicted Mortality")) +
  labs(title = "Observed vs Predicted Mortality", y = "Mortality",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("blue", "orange"))

ggplot() +
  geom_line(aes(x=influanza$Week,y=influanza$Mortality,
                         colour=as.factor(influanza$Year))) +
  labs(x='Week', y='Mortality', colour='Year',
       title='Mortality by Week and by Year')

```

**Comment:** We can see that the fitted data is actually not performing that bad. It recognized the cyclical trend correctly. The drawback of the smoothing is that the extrem values are not correctly predicted, as those are smoothed out.

We observe that the spline curve is following the trend we can observe over the years, with a peak in the beginning/end of the year.

## 1.4)

**Task:** Examine how the penalty factor of the spline function in the GAM model from step 2 influences the estimated deviance of the model. Make plots of the predicted and observed mortality against time for cases of very high and very low penalty factors. What is the relation of the penalty factor to the degrees of freedom? Do your results confirm this relationship?

```{r, echo = FALSE}

################################################################################
# 1.4) 
################################################################################

penalties = seq(from = 0 , to = 20, by = 0.1)
index = 1

fitted_gam_with_penalties = data.frame()

for (penalty in penalties) {
  gam_model = gam(formula = Mortality ~ Year +
                    s(Week, sp = penalty, k = length(unique(influanza$Week))),
                  family = gaussian(), data = influanza, method="GCV.Cp") 
  
  fitted_gam_with_penalties = rbind(fitted_gam_with_penalties,
        data.frame(list(penalty = penalty,
                        deviance = gam_model$deviance,
                        df = sum(influence(gam_model)))))
}

## Deviance VS Penalty
ggplot(fitted_gam_with_penalties) +
  geom_line(aes(x = fitted_gam_with_penalties$penalty,
                y = fitted_gam_with_penalties$deviance,
                colour = "Deviance/Penalty")) +
  labs(title = "Deviance VS Penalty", y = "Deviance",
       x = "Penalty", color = "Legend") +
  scale_color_manual(values = c("blue", "orange"))

## Penalty Factors vs Degrees of Freedom
ggplot(fitted_gam_with_penalties) +
  geom_line(aes(x = fitted_gam_with_penalties$deviance,
                y = fitted_gam_with_penalties$df,
                colour = "Degrees of Freedom/Deviance")) +
  labs(title = "Deviance VS Degrees of Freedom", y = "Degrees of Freedom",
       x = "Deviance/DF", color = "Legend") +
  scale_color_manual(values = c("blue", "orange"))

## Create Models for High and Low penalties
gam_model_low_pen = gam(formula = Mortality ~ Year + s(Week, sp = 0.1),
                  family = gaussian(), data = influanza, method="GCV.Cp") 
gam_model_high_pen = gam(formula = Mortality ~ Year + s(Week, sp = 20),
                  family = gaussian(), data = influanza, method="GCV.Cp") 

high_low_df = data.frame()
high_low_df = rbind(high_low_df,
                    list(mortality = influanza$Mortality,
                          mortality_low = fitted(gam_model_low_pen),
                          mortality_high = fitted(gam_model_high_pen),
                          date = influanza$Time))

ggplot(high_low_df) +
  geom_line(aes(x = date, y = mortality, colour = "Mortality")) +
  geom_line(aes(x = date, y = mortality_low, colour = "Mortality (Low)")) +
  geom_line(aes(x = date, y = mortality_high, colour = "Mortality (High)")) +
  labs(title = "Mortalities vs Time", y = "Mortality",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("blue", "orange", "violet"))

## Observed vs Predicted Mortality
ggplot(mortality_values) +
  geom_line(aes(x = time, y = observed,
                colour = "Observed Mortality")) +
  geom_line(aes(x = time, y = predicted,
                colour = "Predicted Mortality")) +
  labs(title = "Observed vs Predicted Mortality", y = "Mortality",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("blue", "orange"))

```

In the first plot we see, that with an increase in penalty the deviance increases as well. The greater the penalty the simpler is teh model, so this is kind of what we expect. For the plot with a low and high penalty we can see, that the model with a low penalty performs better in the way that it better follows the original trends while the model with the high penalty struggles to catch the individuals trends/spikes.

## 1.5)

**Task:** Use the model obtained in step 2 and plot the residuals and the influenza values against time (in one plot). Is the temporal pattern in the residuals correlated to the outbreaks of influenza?

```{r, echo = FALSE}

################################################################################
# 1.5) 
################################################################################

time = influanza$Time
resid = gam_model$residuals
influenza_data = influanza$Influenza

print_data = data.frame(time, resid, influenza_data)

ggplot(print_data) +
  geom_line(aes(x = time, y = resid,
                colour = "Residuals")) +
  geom_line(aes(x = time, y = influenza_data,
                colour = "Influenza")) +
  labs(title = "Residuals and Influenza vs Time", y = "Residuals and Mortality",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("blue", "orange"))

```

**Comment:** Yes it seems like that the residuals and the outbreaks are correlated. When there is an outbreak, the residuals also inscrease in that particular moment.

## 1.6)

**Task:** Fit a GAM model in R in which mortality is be modelled as an additive function of the spline functions of year, week, and the number of confirmed cases of influenza. Use the output of this GAM function to conclude whether or not the mortality is influenced by the outbreaks of influenza. Provide the plot of the original and fitted Mortality against Time and comment whether the model seems to be better than the previous GAM models.

```{r, echo = FALSE}

################################################################################
# 1.6) 
################################################################################

gam_model_additive = gam(formula =
                         Mortality ~ s(Year, k=length(unique(influanza$Year))) +
                         s(Week, k=length(unique(influanza))) +
                         s(Influenza, k=length(unique(influanza$Year))),
                         family = gaussian(), data = influanza, method="GCV.Cp")

summary(gam_model_additive)
plot(gam_model_additive)

time = influanza$Time
observed = influanza$Mortality
predicted = fitted(gam_model_additive)

mortality_values = data.frame(time, observed, predicted)

ggplot(mortality_values) +
  geom_line(aes(x = time, y = observed,
                colour = "Observed Mortality")) +
  geom_line(aes(x = time, y = predicted,
                colour = "Predicted Mortality")) +
  labs(title = "Observed vs Predicted Mortality", y = "Mortality",
       x = "Time", color = "Legend") +
  scale_color_manual(values = c("blue", "orange"))

```

Using the new splines in this model concludes in a better model than before. We see that the week and influence are statistically significant while the year is not. Comparing this statement with the provided plots we see, that the year is not capturing any trend, while the week and the influence are capturing the occuring trends.

# 2) High-dimensional method

The data file data.csv contains information about 64 e-mails which were manually collected from DBWorld mailing list. They were classified as: 'announces of conferences' (1) and 'everything else' (0) (variable Conference)

```{r, echo = FALSE}

################################################################################
# 2) High-dimensional method
################################################################################

emails = read.csv2("data.csv", fileEncoding = "ISO-8859-1", sep = ";")
emails$Conference = as.factor(emails$Conference)
kable(head(emails[,1:10]))

n = dim(emails)[1]
id = sample(1:n, floor(n*0.70))
train_emails = emails[id,]
val_emails = emails[-id,]

```

## 2.1)

- Divide data into training and test sets (70/30) without scaling.
- Perform nearest shrunken centroid classification of training data in which the threshold is chosen by cross-validation.
- Provide a centroid plot and interpret it. How many features were selected by the method?
- List the names of the 10 most contributing features and comment whether it is reasonable that they have strong effect on the discrimination between the conference mails and other mails?
- Report the test error.

```{r, echo = FALSE, results='hide'}

################################################################################
# 2.1)
################################################################################

rownames(train_emails) = 1:nrow(train_emails)
x_train = t(train_emails[,-ncol(train_emails)])
y_train = train_emails[[ncol(train_emails)]]
mydata_train = list(x=x_train ,y=as.factor(y_train), geneid =
                      as.character(1:nrow(x_train)),
              genenames = rownames(x_train))

nsc_model = pamr.train(mydata_train, threshold=seq(0, 4, 0.1))
nsc_model_cv = pamr.cv(nsc_model, mydata_train)

genes = pamr.listgenes(nsc_model, mydata_train, threshold = 2.5)

```

```{r, echo = FALSE}

pamr.plotcen(nsc_model, mydata_train, threshold = 2.5)

print(nsc_model_cv)
pamr.plotcv(nsc_model_cv)

```

The amount of features selected is:

```{r, echo = FALSE}

nrow(genes)

```

And the 10 most contributing features are:

```{r, echo = FALSE}

kable(colnames(emails)[as.numeric(genes[1:10, 1])])

```

We have the following confuses matrices.

```{r, echo = FALSE}

rownames(val_emails) = 1:nrow(val_emails)
x_val = t(val_emails[,-ncol(val_emails)])
y_val = val_emails[[ncol(val_emails)]]
#mydata_val = list(x=x_val ,y=as.factor(y_val),
# geneid = as.character(1:nrow(x_val)),
#              genenames = rownames(x_val))

pred_train = pamr.predict(nsc_model, newx = x_train, threshold = 2.5)
pred_val = pamr.predict(nsc_model, newx = x_val, threshold = 2.5)

matrix_train = table(train_emails$Conference, pred_train)
matrix_val = table(val_emails$Conference, pred_val)

kable(matrix_train)
kable(matrix_val)

```

And therefor the following error rates:

```{r, echo = FALSE}

error_train_nsc = 1 - sum(diag(matrix_train)/sum(matrix_train))
error_val_scn = 1 - sum(diag(matrix_val)/sum(matrix_val))

print(paste("Error Train:", error_train_nsc))
print(paste("Error Validation:", error_val_scn))

```

**TODO:**

- Threshold?
- Interpretation of the Centroid Plots!

## 2.2)

Compute the test error and the number of the contributing features for the following methods fitted to the training data:

  - Elastic net with the binomial response and a = 0.5 in which penalty is selected by the cross-validation
  - Support vector machine with "vanilladot"" kernel.
  
Compare the results of these models with the results of the nearest shrunken centroids (make a comparative table). Which model would you prefer and why?

```{r, echo = FALSE}

################################################################################
# 2.3) 
################################################################################

# Elastic Net

# Predictor Variables. The -1 removes the intercept component
x_test = as.matrix(train_emails[, -ncol(train_emails)])
x_val = as.matrix(val_emails[, -ncol(val_emails)])

# Outcome variable
y_test = train_emails$Conference
y_val = val_emails$Conference

model_elastic_net = cv.glmnet(x = x_test, y = y_test, alpha = 0.5,
                              family = "binomial")

# Support vector machine with "vanilladot" kernel.
# Vanilladot means "Linear Kernel Function"
# set scale = FALSE to prevent "variable(s) `' constant. Cannot scale data.""
model_svm = ksvm(x = x_test, y = y_test, kernel = "vanilladot", scale = FALSE)

# Predictions
pred_val_elastic = predict(model_elastic_net, newx = x_val, type = "class")
pred_val_svm = predict(model_svm, x_val, type = "response")

matrix_elastic = table(y_val, t(pred_val_elastic))
matrix_svm = table(y_val, pred_val_svm)

kable(matrix_elastic)
kable(matrix_svm)

```

```{r, echo = FALSE}

error_elastic = 1 - sum(diag(matrix_elastic)/sum(matrix_elastic))
error_svm = 1 - sum(diag(matrix_svm)/sum(matrix_svm))

print(paste("Error Elastic:", error_elastic))
print(paste("Error SVM:", error_svm))

```

Data about the elastic model:

```{r, echo = FALSE}

#print(model_elastic_net)
summary(model_elastic_net)
plot(model_elastic_net)

```

Data bout the svm model:

```{r, echo = FALSE}

print(model_svm)
summary(model_svm)
#plot(model_svm)

```

To get an overview over all trained model errors, let's have a look at the following table. The error rates are based on the test/validation data set, not on the train data set.

```{r, echo = FALSE}

plot_table = data.frame(
  NSCM_error = error_val_scn,
  Elastic_error = error_elastic,
  SVM_error = error_svm
)

kable(plot_table)

```

Therefore the best model is the SVM model as it has the smallest error. We shoudk keep in mind that if works with all features while NSCM uses less features. As the dataset is small and the computations are done quickly, the benefit of little features vanishes and we still take the SVM model. The elastic error is just to high to be considered.

## 2.3)

**Task:** Implement Benjamini-Hochberg method for the original data, and use t.test() for computing p-values. Which features correspond to the rejected hypotheses? Interpret the result.

```{r, echo = FALSE}

################################################################################
# 2.3) 
################################################################################

# Orignal Data Set: emails
# H0: Feature has effect on Conference
# Ha: Feature has no effect on Conference

# 1) Calculate p-values
# 2) Assign ranks and sort
# 3) BH Critical Value
# 4) Find critical value and select all p < score

q_value = 0.05

## 1)

feature_names = c()
p_values = c()

# For each data point calculate the p_value

for (i in 1:(ncol(emails)-1)) {
  colname = colnames(emails)[i]
  c_formula = paste(sep = "", colname, " ~ Conference")
  p_value = t.test(as.formula(c_formula), data = emails,
                   alternative="two.sided")
  
  feature_names = c(feature_names, colname)
  p_values = c(p_values, p_value$p.value)
}

## 2)

# Sorting
bh_entries = data.frame(feature_names, p_values)
bh_entries = bh_entries[order(bh_entries$p_values, decreasing = FALSE),]
rownames(bh_entries) = NULL

## 3)

# Define the function for the CV-Score
getCV_BH = function(i, m, Q) {
  return(i/m*Q)
}

cv_scores = c()

for (j in 1:nrow(bh_entries)) {
  current_val = getCV_BH(as.numeric(rownames(bh_entries)[j]),
                         nrow(bh_entries), q_value)
  cv_scores = c(cv_scores, current_val)
}

#cv_col = apply(bh_entries, 1, function(x)
#getCV_BH(as.numeric(rownames(bh_entries)), nrow(bh_entries), q_value))
bh_entries = data.frame(bh_entries, cv_scores)

## 4)
## Find all rows where p_values < cv_scores
bh_entries = bh_entries[bh_entries$p_values < bh_entries$cv_scores,]

```

**Answer:** As there is no $\alpha$ level given, we choose it as $\alpha = 0.05$. The implemented method can be found in the source code appendix.

After applying the BH-method, we have `39` features left, which are the following (inculdung their p_values and cv_scores).

```{r}

kable(bh_entries)

```

The purpose of the BH-method is to decrease the FDR (False Discovery Rate). The last entry in the list has the highest p_value, which is smaller then the cirtical value. This means that all values after that (here truncated) are considered significant. This means, for those values $H_0$ is rejected.

# Appendix

```{r, ref.label = knitr::all_labels(), echo = TRUE, eval = FALSE}

```

# Bibliography