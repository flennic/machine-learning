---
title: "Lab 3 Block 1: Kernel Meethods and Neural Networks"
author: "Maximilian Pfundstein"
date: "9 December 2018"
output:
  html_document:
    df_print: paged
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: 3
  word_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(geosphere)

```

# Kernel Methods

**Task:**

- Implement a kernel method to predict the hourly temperatures for a date and place in Sweden.
- You are asked to provide a temperature forecast for a date and place in Sweden. The
forecast should consist of the predicted te mperatures from 4 am to 24 pm in an interval of 2
hours.
- Use a kernel that is the sum of three Gaussian kernels.
  - The first to account for the distance from a station to the point of interest.
  - The second to account for the distance between the day a temperature measurement
was made and the day of interest.
  - The third to account for the distance between the hour of the day a temperature measurement
was made and the hour of interest.
- Choose an appropriate smoothing coefficient or width for each of the three kernels above.
- Show that your choice for the kernels' width is sensible, i.e. that it gives more weight
to closer points. Discuss why your of definition of closeness is reasonable.
- Instead of combining the three kernels into one by summing them up, multiply them.
Compare the results obtained in both cases and elaborate on why they may differ.

*Note that the file temps50k.csv may contain temperature measurements that are posterior
to the day and hour of your forecast. You must filter such measurements out, i.e. they cannot
be used to compute the forecast. Feel free to use the template below to solve the assignment.*

```{r, echo = FALSE, eval = FALSE}

################################################################################
# Kernel Methods
################################################################################

# Helper functions

## Kernels
## The definition for the Guassian Kernel is taken from the slides, page 6.

kernel_gauss_distance = function(pointA, pointB, smoothing) {
  # Use distHaversine() as a help
  u = distHaversine(c(pointA$latitude, pointA$longitude),
                    c(pointB$latitude, pointB$longitude))
  u = u / smoothing
  return(exp(-(u^2)))
}

kernel_gauss_day = function(dayA, dayB, smoothing) {
  u = as.numeric(as.Date(dayA$date)-as.Date(dayB$date))
  u = u / smoothing
  return(exp(-(u^2)))
}

kernel_gauss_hour = function (hourA, hourB, smoothing) {
  u = as.numeric(difftime(strptime(hourA$time, format = "%H:%M:%S"),
                          strptime(hourB$time, format = "%H:%M:%S")))
  u = u / smoothing
  return(exp(-(u^2)))
}

kernel_sum = function(A, B, h_distance, h_date, h_time) {
  return(
    kernel_gauss_distance(A, B, h_distance) + 
    kernel_gauss_day(A, B, h_date) + 
    kernel_gauss_hour(A, B, h_time)
  )
}

kernel_product = function(A, B, h_distance, h_date, h_time) {
  return(
    kernel_gauss_distance(A, B, h_distance) * 
    kernel_gauss_day(A, B, h_date) * 
    kernel_gauss_hour(A, B, h_time)
  )
}

predict_weather = function(u_latitude, u_longtitude, u_date, u_type) {
  
  # Data
  stations = read.csv("stations.csv", encoding = "UTF-8")
  temps = read.csv("temps50k.csv", encoding = "UTF-8")
  st = merge(stations, temps, by="station_number")
  
  # Given Data
  # Each user input should be a list of:
  # latitude, longitude, date, time
  # time is created with the loop at we predict for every time for the given day
  
  # Times to predict
  times = c("04:00:00", "06:00:00", "08:00:00", "10:00:00", "12:00:00",
           "14:00:00", "16:00:00", "18:00:00", "20:00:00", "22:00:00",
           "24:00:00")
  # Temperatures to predict
  temp = vector(length=length(times))
  
  # Smoothing factors
  h_distance = 10
  h_date = 10
  h_time = 10
  
  # Prediction for each temp to predict
  for (i in 1:length(times)) {
    
    # User data point for this iteration
    user_data_point = list(
      latitude = u_latitude,
      longitude = u_longtitude,
      date = u_date,
      time = times[i])
    
    if (u_type == "sum") {
      # Parameters: A, B, h_distance, h_date, h_time
      k_sum = kernel_sum(user_data_point, st, h_distance, h_distance, h_time)
    }
    else if (u_type == "prod") {
      # Parameters: A, B, h_distance, h_date, h_time
      k_prod =
        kernel_product(user_data_point, st, h_distance, h_distance, h_time))
    }
    else {
      stop("Du Nasenb√§r!")
    }
    
    ## Calculate the kernel sum and product
    
    
    
  }
  
  return("lala")
}

set.seed(1234567890)

a <- 58.4274 # The point to predict (up to the students)
b <- 14.826
date <- "2013-11-04" # The date to predict (up to the students)

# Students' code here

predict_weather(a, b, date)

plot(temp, type="o")

```



# Support Vector Machines

**Task:**

- Use the function ksvm from the R package kernlab to learn a SVM for classifying the
spam dataset that is included with the package.
  - Consider the radial basis function kernel (also
known as Gaussian) with a width of 0.05. For the C parameter, consider values 0.5, 1 and 5.
This implies that you have to consider three models.
- Perform model selection, i.e. select the most promising of the three models (use any
method of your choice except cross-validation or nested cross-validation).
- Estimate the generalization error of the SVM selected above (use any method of your
choice except cross-validation or nested cross-validation).
- Produce the SVM that will be returned to the user, i.e. show the code.
- What is the purpose of the parameter C?

```{r, echo = FALSE}

################################################################################
# Support Vector Machines
################################################################################



```



# Appendix: Source Code

```{r, ref.label=knitr::all_labels(), echo = TRUE, eval = FALSE}

```